/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hw.langchain.chains.base;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static com.google.common.base.Preconditions.checkArgument;

/**
 * @description: Base interface that all chains should implement.
 * @author: HamaWhite
 */
public abstract class Chain {

    /**
     * Input keys this chain expects.
     */
    public abstract List<String> inputKeys();

    /**
     * Output keys this chain expects.
     */
    public abstract List<String> outputKeys();

    /**
     * Run the logic of this chain and return the output.
     */
    public abstract Map<String, String> _call(Map<String, ?> inputs);

    /**
     * Run the logic of this chain and add to output if desired.
     *
     * @param input             single input if chain expects only one param.
     * @param returnOnlyOutputs boolean for whether to return only outputs in the response.
     *                          If True, only new keys generated by this chain will be returned.
     *                          If False, both input keys and new keys generated by this chain will be returned.
     *                          Defaults to False.
     */
    private Map<String, String> call(String input, boolean returnOnlyOutputs) {
        Map<String, String> inputs = prepInputs(input);
        return call(inputs, returnOnlyOutputs);
    }

    /**
     * Run the logic of this chain and add to output if desired.
     *
     * @param inputs            Dictionary of inputs.
     * @param returnOnlyOutputs boolean for whether to return only outputs in the response.
     *                          If True, only new keys generated by this chain will be returned.
     *                          If False, both input keys and new keys generated by this chain will be returned.
     *                          Defaults to False.
     */
    private Map<String, String> call(Map<String, String> inputs, boolean returnOnlyOutputs) {
        Map<String, String> outputs = _call(inputs);
        return prepOutputs(inputs, outputs, returnOnlyOutputs);
    }

    /**
     * Run the chain as text in, text out
     */
    public String run(String args) {
        validateOutputKeys();
        return call(args, false).get(outputKeys().get(0));
    }

    /**
     * Run the chain as multiple variables, text out.
     */
    public String run(Map<String, String> args) {
        validateOutputKeys();
        return call(args, false).get(outputKeys().get(0));
    }

    private void validateOutputKeys() {
        List<String> outputKeys = outputKeys();
        checkArgument(outputKeys.size() == 1,
                "run not supported when there is not exactly one output key. Got %s",
                outputKeys);
    }

    /**
     * Validate and prep inputs.
     */
    private Map<String, String> prepInputs(String inputs) {
        List<String> inputKeys = inputKeys();
        checkArgument(inputKeys.size() == 1,
                "A single string input was passed in, but this chain expects multiple inputs (%s)", inputKeys);
        return Map.of(inputKeys.get(0), inputs);
    }

    /**
     * Validate and prep outputs.
     */
    private Map<String, String> prepOutputs(Map<String, String> inputs, Map<String, String> outputs,
            boolean returnOnlyOutputs) {
        if (returnOnlyOutputs) {
            return outputs;
        }
        Map<String, String> resultMap = new HashMap<>(inputs);
        resultMap.putAll(outputs);
        return resultMap;
    }

}
